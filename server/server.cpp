#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <ctime>

// #define PORT 3496 // the port users will be connecting to
#define QUEUE_SIZE 5 // how many pending connections the queue will hold

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: ./server PORT\n");
        exit(-1);
    }

    const int PORT = atoi(argv[1]);

    int socket1; // listen on sock_fd
    int socket2; // new connection on new_fd (from accept())
    int status;  // Used for error checking

    // Address initialization
    struct sockaddr_in address;
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;                // IPv4
    address.sin_port = htons(PORT);              // convert port number from Host Byte Order to Network Byte Order
    address.sin_addr.s_addr = htonl(INADDR_ANY); // accept connection from any IP address

    // Socket creation
    socket1 = socket(PF_INET, SOCK_STREAM, 0); // use PF_INET instead of AF_INET in the socket creation
    if (socket1 == -1)
    {
        std::cout << "server: failed to create socket1" << std::endl;
        return 1;
    }

    // Binding
    // We bind together the address structure and socket1
    status = bind(socket1, (struct sockaddr *)&address, sizeof(struct sockaddr_in));
    if (status == -1)
    {
        printf("server: bind failed\n");
        return 2;
    }

    while (1)
    {
        // Listening
        // The second argument is the maximum number of connections that can wait in the queue
        status = listen(socket1, QUEUE_SIZE);
        if (status == -1)
        {
            printf("server: listen failed\n");
            return 3;
        }

        // Accepting connections
        // The second argument is a pointer to a struct sockaddr, which holds the address of the client. We don't
        // care about the address of the client, so we set it to NULL.
        // The third argument is a pointer to an integer that is used to store the size of the struct sockaddr that was passed
        // as the second argument. Since we passed in NULL as the second argument, we pass in NULL for the third argument as well.
        socket2 = accept(socket1, NULL, NULL);
        if (socket2 == -1)
        {
            printf("server: accept failed\n");
            return 4;
        }

        // This will hold the message sent by the client
        char ucid[100];
        int message_length;

        // Receive message from client
        status = recv(socket2, ucid, 100, 0);
        if (status == -1)
        {
            printf("server: failed to receive UCID from client\n");
            return 5;
        }

        if (ucid[0] == 'q' && ucid[1] == '!' && ucid[2] == '\0')
        {
            printf("Server shutting down...\n");
            // break;
            close(socket1);
            exit(0);
        }

        // std::cout << "Return value of recv(): " << status << std::endl;
        std::cout << "Received UCID from client: " << ucid << std::endl;
        std::cout << "Size of UCID message: " << strlen(ucid) << std::endl
                  << std::endl;

        // Get the current data and time on our system
        // Source: https://www.educative.io/answers/how-to-get-the-current-date-and-time-in-cpp
        time_t now = time(0);
        // Convert date and time to C-style string format
        // Note that the NULL terminator is at index 25
        char *date_and_time = ctime(&now);

        // Send the date and time back to the client
        status = send(socket2, date_and_time, strlen(date_and_time) + 1, 0);
        if (status == -1)
        {
            printf("server: failed to send date and time to client\n");
            return 6;
        }
        std::cout << "Sending date and time: " << date_and_time << std::endl;
        std::cout << "Size of date and time: " << sizeof(date_and_time) << std::endl;
        std::cout << "Length of date and time: " << strlen(date_and_time) << std::endl
                  << std::endl;

        // The passcode is generated by both the client and server!
        char server_passcode[7] = {date_and_time[17], date_and_time[18], ucid[4], ucid[5], ucid[6], ucid[7], '\0'};
        std::cout << "Passcode generated: " << server_passcode << std::endl;

        // Receive the passcode generated on the client side
        char client_passcode[7];
        status = recv(socket2, client_passcode, 7, 0);
        if (status == -1)
        {
            printf("server: failed to receive CLIENT PASSCODE\n");
            return 7;
        }
        // Now validate the passcode
        bool authenticated;
        if (strcmp(client_passcode, server_passcode) == 0)
        {
            authenticated = true;
            std::cout << "Passcodes Match!" << std::endl;
        }
        else
        {
            authenticated = false;
            std::cout << "PASSCODE MISMATCH! Unknown client." << std::endl;
        }

        // Read the file and send to client
        if (authenticated)
        {
            // Open the file
            std::ifstream file("data.txt");

            std::string line;
            std::vector<std::string> all_lines;
            int n = 0;
            // Read the lines
            while (std::getline(file, line))
            {
                n++;
                all_lines.push_back(line);
            }
            std::cout << "Number of lines in file: " << n << std::endl;
            // Convert the number of lines to a C-string
            std::string m = std::to_string(n);
            std::cout << "Number of lines as C++ string: " << m << std::endl;

            char *num_lines = new char(m.length() + 1);
            int i = 0;
            for (char c : m)
            {
                num_lines[i] = c;
                i++;
            }
            num_lines[i] = '\0';
            printf("Number of lines as C string: %s\n", num_lines);

            // Now send this "number" to the client
            status = send(socket2, num_lines, strlen(num_lines) + 1, 0);
            if (status == -1)
            {
                printf("server: failed to send number of lines in file\n");
                return 8;
            }
            printf("Succesfully sent number of lines in file to client\n");

            // Free memory
            delete[] num_lines;

            // Now send each line in the vector to the client, element by element
            for (std::string s : all_lines)
            {
                int i = 0;
                char* line_to_send = new char(s.length()+1);
                for (char c : m)
                {
                    line_to_send[i] = c;
                    i++;
                }
                line_to_send[i] = '\0';

                status = send(socket2, line_to_send, strlen(line_to_send)+1, 0);
                if (status == -1)
                {
                    printf("server: failed to send line to client\n");
                    return 9;
                }
                printf("Successfully sent line to client\n");
            }

            file.close();
        }

        // Close the second socket
        close(socket2);
    }

    close(socket1);

    return 0;
}