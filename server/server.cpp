#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string>
#include <chrono>
#include <thread>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <ctime>

// #define PORT 3496 // the port users will be connecting to
#define QUEUE_SIZE 5 // how many pending connections the queue will hold

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: ./server PORT\n");
        exit(-1);
    }

    const int PORT = atoi(argv[1]);

    int socket1; // listen on sock_fd
    int socket2; // new connection on new_fd (from accept())
    int status;  // Used for error checking

    // Address initialization
    struct sockaddr_in address;
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;                // IPv4
    address.sin_port = htons(PORT);              // convert port number from Host Byte Order to Network Byte Order
    address.sin_addr.s_addr = htonl(INADDR_ANY); // accept connection from any IP address

    // Socket creation
    socket1 = socket(PF_INET, SOCK_STREAM, 0); // use PF_INET instead of AF_INET in the socket creation
    if (socket1 == -1)
    {
        std::cout << "server: failed to create socket1" << std::endl;
        return 1;
    }

    // Binding
    // We bind together the address structure and socket1
    status = bind(socket1, (struct sockaddr *)&address, sizeof(struct sockaddr_in));
    if (status == -1)
    {
        printf("server: bind failed\n");
        return 2;
    }

    while (1)
    {
        // Listening
        // The second argument is the maximum number of connections that can wait in the queue
        status = listen(socket1, QUEUE_SIZE);
        if (status == -1)
        {
            printf("server: listen failed\n");
            return 3;
        }
        printf("Listening for connection...\n");
        // Accepting connections
        // The second argument is a pointer to a struct sockaddr, which holds the address of the client. We don't
        // care about the address of the client, so we set it to NULL.
        // The third argument is a pointer to an integer that is used to store the size of the struct sockaddr that was passed
        // as the second argument. Since we passed in NULL as the second argument, we pass in NULL for the third argument as well.
        socket2 = accept(socket1, NULL, NULL);
        if (socket2 == -1)
        {
            printf("server: accept failed\n");
            return 4;
        }
        printf("Client connected!\n");
        printf("================================\n");

        // This will hold the message sent by the client
        char ucid[100];
        int message_length;

        // Receive message from client
        status = recv(socket2, ucid, 100, 0);
        if (status == -1)
        {
            printf("server: failed to receive UCID from client\n");
            return 5;
        }

        if (ucid[0] == 'q' && ucid[1] == '!' && ucid[2] == '\0')
        {
            printf("Server shutting down...\n");
            // break;
            close(socket2);
            close(socket1);
            exit(0);
        }

        // std::cout << "Return value of recv(): " << status << std::endl;
        std::cout << "Received UCID from client: " << ucid << std::endl;

        // Get the current data and time on our system
        // Source: https://www.educative.io/answers/how-to-get-the-current-date-and-time-in-cpp
        time_t now = time(0);
        // Convert date and time to C-style string format
        // Note that the NULL terminator is at index 25
        char *date_and_time = ctime(&now);

        // Send the date and time back to the client
        status = send(socket2, date_and_time, strlen(date_and_time) + 1, 0);
        if (status == -1)
        {
            printf("server: failed to send date and time to client\n");
            return 6;
        }

        // The passcode is generated by both the client and server!
        char server_passcode[5];
        char ucid_last_four[5] = {ucid[4], ucid[5], ucid[6], ucid[7], '\0'}; // Extract the last four digits from the UCID
        int ucid_to_int = atoi(ucid_last_four);                              // Convert the last four UCID digits to an int
        char seconds[3] = {date_and_time[17], date_and_time[18], '\0'};      // Extract seconds from date_and_time as string
        int seconds_to_int = atoi(seconds);                                  // Convert seconds to int
        int passcode_as_int = ucid_to_int + seconds_to_int;                  // Add the ucid and passcodes that were converted to ints
        sprintf(server_passcode, "%d", passcode_as_int);                     // Convert the passcode from int to string

        std::cout << "Server Passcode generated: " << server_passcode << std::endl;

        // Receive the passcode generated on the client side
        char client_passcode[7];
        status = recv(socket2, client_passcode, 7, 0);
        if (status == -1)
        {
            printf("server: failed to receive CLIENT PASSCODE\n");
            return 7;
        }
        std::cout << "Client Passcode received! Verifying..." << std::endl;

        // Now validate the passcode
        bool authenticated;
        if (strcmp(client_passcode, server_passcode) == 0)
        {
            authenticated = true;
            std::cout << "Passcodes Match!" << std::endl;
        }
        else
        {
            authenticated = false;
            std::cout << "PASSCODE MISMATCH! Unknown client." << std::endl;
            continue;
        }

        // Read the file and send to client
        if (authenticated)
        {
            // This stores the data on the current line from the file
            std::string current_line;
            // This is the file to read from
            std::ifstream file("data.txt");

            // Read each line of the file, and store into the line variable
            while (std::getline(file, current_line))
            {
                const char* send_line = current_line.c_str();
                status = send(socket2, send_line, strlen(send_line)+1, 0);
                if (status == -1)
                {
                    printf("server: Failed to send line to client\n");
                    return 8;
                }
                // Source: https://stackoverflow.com/questions/4184468/sleep-for-milliseconds
                // Sleep for half a second after sending
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
            }
        }

        // Close the second socket
        printf("Closing connection to client!\n\n");
        close(socket2);
    }

    close(socket1);

    return 0;
}