#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <ctime>

// #define PORT 3496 // the port users will be connecting to
#define QUEUE_SIZE 5 // how many pending connections the queue will hold

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: ./server PORT\n");
        exit(-1);
    }

    const int PORT = atoi(argv[1]);

    int socket1; // listen on sock_fd
    int socket2; // new connection on new_fd (from accept())
    int status;  // Used for error checking

    // Address initialization
    struct sockaddr_in address;
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;                // IPv4
    address.sin_port = htons(PORT);              // convert port number from Host Byte Order to Network Byte Order
    address.sin_addr.s_addr = htonl(INADDR_ANY); // accept connection from any IP address

    // Socket creation
    socket1 = socket(PF_INET, SOCK_STREAM, 0); // use PF_INET instead of AF_INET in the socket creation
    if (socket1 == -1)
    {
        std::cout << "server: failed to create socket1" << std::endl;
        return 1;
    }

    // Binding
    // We bind together the address structure and socket1
    status = bind(socket1, (struct sockaddr *)&address, sizeof(struct sockaddr_in));
    if (status == -1)
    {
        printf("server: bind failed\n");
        return 2;
    }

    while (1)
    {
        // Listening
        // The second argument is the maximum number of connections that can wait in the queue
        status = listen(socket1, QUEUE_SIZE);
        if (status == -1)
        {
            printf("server: listen failed\n");
            return 3;
        }

        // Accepting connections
        // The second argument is a pointer to a struct sockaddr, which holds the address of the client. We don't
        // care about the address of the client, so we set it to NULL.
        // The third argument is a pointer to an integer that is used to store the size of the struct sockaddr that was passed
        // as the second argument. Since we passed in NULL as the second argument, we pass in NULL for the third argument as well.
        socket2 = accept(socket1, NULL, NULL);
        if (socket2 == -1)
        {
            printf("server: accept failed\n");
            return 4;
        }

        // This will hold the message sent by the client
        char ucid[100];
        int message_length;

        // Receive message from client
        status = recv(socket2, ucid, 100, 0);
        if (status == -1)
        {
            printf("server: failed to receive UCID from client\n");
            return 5;
        }

        if (ucid[0] == 'q' && ucid[1] == '!' && ucid[2] == '\0')
        {
            printf("Server shutting down...\n");
            // break;
            close(socket1);
            exit(0);
        }

        // std::cout << "Return value of recv(): " << status << std::endl;
        std::cout << "Received UCID from client: " << ucid << std::endl;
        std::cout << "Size of UCID message: " << strlen(ucid) << std::endl
                  << std::endl;

        // Get the current data and time on our system
        // Source: https://www.educative.io/answers/how-to-get-the-current-date-and-time-in-cpp
        time_t now = time(0);
        // Convert date and time to C-style string format
        // Note that the NULL terminator is at index 25
        char *date_and_time = ctime(&now);

        // Send the date and time back to the client
        status = send(socket2, date_and_time, strlen(date_and_time) + 1, 0);
        if (status == -1)
        {
            printf("server: failed to send date and time to client\n");
            return 6;
        }
        std::cout << "Sending date and time: " << date_and_time << std::endl;
        std::cout << "Size of date and time: " << sizeof(date_and_time) << std::endl;
        std::cout << "Length of date and time: " << strlen(date_and_time) << std::endl
                  << std::endl;

        // The passcode is generated by both the client and server!
        char server_passcode[7] = {date_and_time[17], date_and_time[18], ucid[4], ucid[5], ucid[6], ucid[7], '\0'};
        std::cout << "Passcode generated: " << server_passcode << std::endl;

        // Receive the passcode generated on the client side
        char client_passcode[7];
        status = recv(socket2, client_passcode, 7, 0);
        if (status == -1)
        {
            printf("server: failed to receive CLIENT PASSCODE\n");
            return 7;
        }
        // Now validate the passcode
        bool authenticated;
        if (strcmp(client_passcode, server_passcode) == 0)
        {
            authenticated = true;
            std::cout << "Passcodes Match!" << std::endl;
        }
        else
        {
            authenticated = false;
            std::cout << "PASSCODE MISMATCH! Unknown client." << std::endl;
        }

        // Read the file and send to client
        if (authenticated)
        {
            char filename[100] = "data.txt";
            char all_lines[100];
            // Open the file in read-only mode
            FILE *file = fopen(filename, "r");

            if (file == NULL)
            {
                printf("Failed to open file %s\n", filename);
                exit(1);
            }

            while (fread(all_lines, 1, sizeof(all_lines), file) > 0)
            {
                status = send(socket2, all_lines, strlen(all_lines), 0);
                if (status == -1)
                {
                    printf("server: failed to send file info\n");
                    return 8;
                }
                printf("\nSuccessfully sent file info to client:\n%s\n", all_lines);
                printf("Size of data sent: %ld\n", strlen(all_lines));
            }
        }

        // Close the second socket
        close(socket2);
    }

    close(socket1);

    return 0;
}